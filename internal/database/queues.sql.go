// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queues.sql

package database

import (
	"context"
)

const getQueue = `-- name: GetQueue :one
SELECT queue_name, is_fifo, created_at
FROM goqueue_queues
WHERE queue_name = $1
LIMIT 1
`

func (q *Queries) GetQueue(ctx context.Context, queueName string) (GoqueueQueue, error) {
	row := q.db.QueryRow(ctx, getQueue, queueName)
	var i GoqueueQueue
	err := row.Scan(&i.QueueName, &i.IsFifo, &i.CreatedAt)
	return i, err
}

const insertQueue = `-- name: InsertQueue :one
INSERT INTO goqueue_queues (queue_name, is_fifo)
VALUES ($1, $2)
ON CONFLICT (queue_name) DO NOTHING
RETURNING queue_name, is_fifo, created_at
`

type InsertQueueParams struct {
	QueueName string `json:"queue_name"`
	IsFifo    bool   `json:"is_fifo"`
}

func (q *Queries) InsertQueue(ctx context.Context, arg InsertQueueParams) (GoqueueQueue, error) {
	row := q.db.QueryRow(ctx, insertQueue, arg.QueueName, arg.IsFifo)
	var i GoqueueQueue
	err := row.Scan(&i.QueueName, &i.IsFifo, &i.CreatedAt)
	return i, err
}

const lockQueue = `-- name: LockQueue :one
SELECT pg_try_advisory_xact_lock(
    hashtext($1)::bigint
) AS acquired
`

func (q *Queries) LockQueue(ctx context.Context, hashtext string) (bool, error) {
	row := q.db.QueryRow(ctx, lockQueue, hashtext)
	var acquired bool
	err := row.Scan(&acquired)
	return acquired, err
}
