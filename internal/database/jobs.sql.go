// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: jobs.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const fetchJob = `-- name: FetchJob :one
UPDATE goqueue_jobs AS j
SET
    status = 'running',
    retry_attempt = j.retry_attempt + 1,
    started_at = NOW()
WHERE job_id = (
    SELECT job_id
    FROM goqueue_jobs AS j2
    WHERE j2.queue_name = $1
      AND j2.status = 'available'
      AND j2.scheduled_at <= NOW()
    ORDER BY j2.created_at
    LIMIT 1
)
RETURNING j.job_id, j.queue_name, j.created_at, j.started_at, j.finished_at, j.scheduled_at, j.max_retries, j.retry_attempt, j.retry_policy, j.status, j.error, j.arguments, j.metadata
`

func (q *Queries) FetchJob(ctx context.Context, queueName string) (GoqueueJob, error) {
	row := q.db.QueryRow(ctx, fetchJob, queueName)
	var i GoqueueJob
	err := row.Scan(
		&i.JobID,
		&i.QueueName,
		&i.CreatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.ScheduledAt,
		&i.MaxRetries,
		&i.RetryAttempt,
		&i.RetryPolicy,
		&i.Status,
		&i.Error,
		&i.Arguments,
		&i.Metadata,
	)
	return i, err
}

const fetchJobLocked = `-- name: FetchJobLocked :one
UPDATE goqueue_jobs AS j
SET
    status = 'running',
    retry_attempt = j.retry_attempt + 1,
    started_at = NOW()
WHERE job_id = (
    SELECT job_id
    FROM goqueue_jobs AS j2
    WHERE j2.queue_name = $1
      AND j2.status = 'available'
      AND j2.scheduled_at <= NOW()
    ORDER BY j2.created_at
    LIMIT 1
    FOR UPDATE SKIP LOCKED
)
RETURNING j.job_id, j.queue_name, j.created_at, j.started_at, j.finished_at, j.scheduled_at, j.max_retries, j.retry_attempt, j.retry_policy, j.status, j.error, j.arguments, j.metadata
`

func (q *Queries) FetchJobLocked(ctx context.Context, queueName string) (GoqueueJob, error) {
	row := q.db.QueryRow(ctx, fetchJobLocked, queueName)
	var i GoqueueJob
	err := row.Scan(
		&i.JobID,
		&i.QueueName,
		&i.CreatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.ScheduledAt,
		&i.MaxRetries,
		&i.RetryAttempt,
		&i.RetryPolicy,
		&i.Status,
		&i.Error,
		&i.Arguments,
		&i.Metadata,
	)
	return i, err
}

const insertJob = `-- name: InsertJob :one
INSERT INTO goqueue_jobs (queue_name, created_at, status, metadata, scheduled_at, arguments, max_retries, retry_policy)
VALUES ($1, NOW(), 'available', $2, $3, $4, $5, $6)
RETURNING job_id, queue_name, created_at, started_at, finished_at, scheduled_at, max_retries, retry_attempt, retry_policy, status, error, arguments, metadata
`

type InsertJobParams struct {
	QueueName   string             `json:"queue_name"`
	Metadata    []byte             `json:"metadata"`
	ScheduledAt pgtype.Timestamp   `json:"scheduled_at"`
	Arguments   []byte             `json:"arguments"`
	MaxRetries  int32              `json:"max_retries"`
	RetryPolicy GoqueueRetryPolicy `json:"retry_policy"`
}

func (q *Queries) InsertJob(ctx context.Context, arg InsertJobParams) (GoqueueJob, error) {
	row := q.db.QueryRow(ctx, insertJob,
		arg.QueueName,
		arg.Metadata,
		arg.ScheduledAt,
		arg.Arguments,
		arg.MaxRetries,
		arg.RetryPolicy,
	)
	var i GoqueueJob
	err := row.Scan(
		&i.JobID,
		&i.QueueName,
		&i.CreatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.ScheduledAt,
		&i.MaxRetries,
		&i.RetryAttempt,
		&i.RetryPolicy,
		&i.Status,
		&i.Error,
		&i.Arguments,
		&i.Metadata,
	)
	return i, err
}

const moveJobToDLQ = `-- name: MoveJobToDLQ :one
UPDATE goqueue_jobs
SET
    queue_name = $1,
    status = 'available',
    retry_attempt = 0,
    scheduled_at = NOW()
WHERE job_id = $2
RETURNING job_id, queue_name, created_at, started_at, finished_at, scheduled_at, max_retries, retry_attempt, retry_policy, status, error, arguments, metadata
`

type MoveJobToDLQParams struct {
	QueueName string `json:"queue_name"`
	JobID     int32  `json:"job_id"`
}

func (q *Queries) MoveJobToDLQ(ctx context.Context, arg MoveJobToDLQParams) (GoqueueJob, error) {
	row := q.db.QueryRow(ctx, moveJobToDLQ, arg.QueueName, arg.JobID)
	var i GoqueueJob
	err := row.Scan(
		&i.JobID,
		&i.QueueName,
		&i.CreatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.ScheduledAt,
		&i.MaxRetries,
		&i.RetryAttempt,
		&i.RetryPolicy,
		&i.Status,
		&i.Error,
		&i.Arguments,
		&i.Metadata,
	)
	return i, err
}

const rescheduleJob = `-- name: RescheduleJob :one
UPDATE goqueue_jobs
SET
    status = 'available',
    scheduled_at = $1
WHERE job_id = $2
RETURNING job_id, queue_name, created_at, started_at, finished_at, scheduled_at, max_retries, retry_attempt, retry_policy, status, error, arguments, metadata
`

type RescheduleJobParams struct {
	ScheduledAt pgtype.Timestamp `json:"scheduled_at"`
	JobID       int32            `json:"job_id"`
}

func (q *Queries) RescheduleJob(ctx context.Context, arg RescheduleJobParams) (GoqueueJob, error) {
	row := q.db.QueryRow(ctx, rescheduleJob, arg.ScheduledAt, arg.JobID)
	var i GoqueueJob
	err := row.Scan(
		&i.JobID,
		&i.QueueName,
		&i.CreatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.ScheduledAt,
		&i.MaxRetries,
		&i.RetryAttempt,
		&i.RetryPolicy,
		&i.Status,
		&i.Error,
		&i.Arguments,
		&i.Metadata,
	)
	return i, err
}

const updateJob = `-- name: UpdateJob :one
UPDATE goqueue_jobs
SET created_at = $1,
    finished_at = $2,
    status = $3,
    error = $4,
    arguments = $5
WHERE job_id = $6
RETURNING job_id, queue_name, created_at, started_at, finished_at, scheduled_at, max_retries, retry_attempt, retry_policy, status, error, arguments, metadata
`

type UpdateJobParams struct {
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	FinishedAt pgtype.Timestamp `json:"finished_at"`
	Status     GoqueueJobStatus `json:"status"`
	Error      pgtype.Text      `json:"error"`
	Arguments  []byte           `json:"arguments"`
	JobID      int32            `json:"job_id"`
}

func (q *Queries) UpdateJob(ctx context.Context, arg UpdateJobParams) (GoqueueJob, error) {
	row := q.db.QueryRow(ctx, updateJob,
		arg.CreatedAt,
		arg.FinishedAt,
		arg.Status,
		arg.Error,
		arg.Arguments,
		arg.JobID,
	)
	var i GoqueueJob
	err := row.Scan(
		&i.JobID,
		&i.QueueName,
		&i.CreatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.ScheduledAt,
		&i.MaxRetries,
		&i.RetryAttempt,
		&i.RetryPolicy,
		&i.Status,
		&i.Error,
		&i.Arguments,
		&i.Metadata,
	)
	return i, err
}

const updateJobFailed = `-- name: UpdateJobFailed :one
UPDATE goqueue_jobs
SET
    status = 'failed',
    error = $1
WHERE job_id = $2
RETURNING job_id, queue_name, created_at, started_at, finished_at, scheduled_at, max_retries, retry_attempt, retry_policy, status, error, arguments, metadata
`

type UpdateJobFailedParams struct {
	Error pgtype.Text `json:"error"`
	JobID int32       `json:"job_id"`
}

func (q *Queries) UpdateJobFailed(ctx context.Context, arg UpdateJobFailedParams) (GoqueueJob, error) {
	row := q.db.QueryRow(ctx, updateJobFailed, arg.Error, arg.JobID)
	var i GoqueueJob
	err := row.Scan(
		&i.JobID,
		&i.QueueName,
		&i.CreatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.ScheduledAt,
		&i.MaxRetries,
		&i.RetryAttempt,
		&i.RetryPolicy,
		&i.Status,
		&i.Error,
		&i.Arguments,
		&i.Metadata,
	)
	return i, err
}

const updateJobFinished = `-- name: UpdateJobFinished :one
UPDATE goqueue_jobs
SET
    status = 'finished',
    finished_at = NOW()
WHERE job_id = $1
RETURNING job_id, queue_name, created_at, started_at, finished_at, scheduled_at, max_retries, retry_attempt, retry_policy, status, error, arguments, metadata
`

func (q *Queries) UpdateJobFinished(ctx context.Context, jobID int32) (GoqueueJob, error) {
	row := q.db.QueryRow(ctx, updateJobFinished, jobID)
	var i GoqueueJob
	err := row.Scan(
		&i.JobID,
		&i.QueueName,
		&i.CreatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.ScheduledAt,
		&i.MaxRetries,
		&i.RetryAttempt,
		&i.RetryPolicy,
		&i.Status,
		&i.Error,
		&i.Arguments,
		&i.Metadata,
	)
	return i, err
}

const updateJobStatus = `-- name: UpdateJobStatus :one
UPDATE goqueue_jobs
SET status = $1
WHERE job_id = $2
RETURNING job_id, queue_name, created_at, started_at, finished_at, scheduled_at, max_retries, retry_attempt, retry_policy, status, error, arguments, metadata
`

type UpdateJobStatusParams struct {
	Status GoqueueJobStatus `json:"status"`
	JobID  int32            `json:"job_id"`
}

func (q *Queries) UpdateJobStatus(ctx context.Context, arg UpdateJobStatusParams) (GoqueueJob, error) {
	row := q.db.QueryRow(ctx, updateJobStatus, arg.Status, arg.JobID)
	var i GoqueueJob
	err := row.Scan(
		&i.JobID,
		&i.QueueName,
		&i.CreatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.ScheduledAt,
		&i.MaxRetries,
		&i.RetryAttempt,
		&i.RetryPolicy,
		&i.Status,
		&i.Error,
		&i.Arguments,
		&i.Metadata,
	)
	return i, err
}
