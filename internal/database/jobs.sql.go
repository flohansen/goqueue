// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: jobs.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const fetchJobLocked = `-- name: FetchJobLocked :one
UPDATE goqueue_jobs
SET
    status = 'pending',
    started_at = NOW()
WHERE job_id = (
    SELECT job_id
    FROM goqueue_jobs
    WHERE status = 'available'
    ORDER BY created_at
    LIMIT 1
    FOR UPDATE SKIP LOCKED
)
RETURNING job_id, created_at, started_at, finished_at, next_retry_at, max_retries, retry_attempt, status, error, arguments
`

func (q *Queries) FetchJobLocked(ctx context.Context) (GoqueueJob, error) {
	row := q.db.QueryRow(ctx, fetchJobLocked)
	var i GoqueueJob
	err := row.Scan(
		&i.JobID,
		&i.CreatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.NextRetryAt,
		&i.MaxRetries,
		&i.RetryAttempt,
		&i.Status,
		&i.Error,
		&i.Arguments,
	)
	return i, err
}

const fetchRescheduableJobsLocked = `-- name: FetchRescheduableJobsLocked :many
SELECT job_id, created_at, started_at, finished_at, next_retry_at, max_retries, retry_attempt, status, error, arguments FROM goqueue_jobs
WHERE status = 'failed'
  AND retry_attempt <= max_retries
  AND NOW() >= next_retry_at
ORDER BY created_at
LIMIT $1
FOR UPDATE SKIP LOCKED
`

func (q *Queries) FetchRescheduableJobsLocked(ctx context.Context, limit int32) ([]GoqueueJob, error) {
	rows, err := q.db.Query(ctx, fetchRescheduableJobsLocked, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GoqueueJob
	for rows.Next() {
		var i GoqueueJob
		if err := rows.Scan(
			&i.JobID,
			&i.CreatedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.NextRetryAt,
			&i.MaxRetries,
			&i.RetryAttempt,
			&i.Status,
			&i.Error,
			&i.Arguments,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertJob = `-- name: InsertJob :one
INSERT INTO goqueue_jobs (created_at, status, arguments)
VALUES (NOW(), 'available', $1)
RETURNING job_id, created_at, started_at, finished_at, next_retry_at, max_retries, retry_attempt, status, error, arguments
`

func (q *Queries) InsertJob(ctx context.Context, arguments []byte) (GoqueueJob, error) {
	row := q.db.QueryRow(ctx, insertJob, arguments)
	var i GoqueueJob
	err := row.Scan(
		&i.JobID,
		&i.CreatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.NextRetryAt,
		&i.MaxRetries,
		&i.RetryAttempt,
		&i.Status,
		&i.Error,
		&i.Arguments,
	)
	return i, err
}

const rescheduleJob = `-- name: RescheduleJob :one
UPDATE goqueue_jobs
SET
    status = 'available',
    retry_attempt = $1
WHERE job_id = $2
RETURNING job_id, created_at, started_at, finished_at, next_retry_at, max_retries, retry_attempt, status, error, arguments
`

type RescheduleJobParams struct {
	RetryAttempt int32 `json:"retry_attempt"`
	JobID        int32 `json:"job_id"`
}

func (q *Queries) RescheduleJob(ctx context.Context, arg RescheduleJobParams) (GoqueueJob, error) {
	row := q.db.QueryRow(ctx, rescheduleJob, arg.RetryAttempt, arg.JobID)
	var i GoqueueJob
	err := row.Scan(
		&i.JobID,
		&i.CreatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.NextRetryAt,
		&i.MaxRetries,
		&i.RetryAttempt,
		&i.Status,
		&i.Error,
		&i.Arguments,
	)
	return i, err
}

const updateJob = `-- name: UpdateJob :one
UPDATE goqueue_jobs
SET created_at = $1,
    finished_at = $2,
    status = $3,
    error = $4,
    arguments = $5
WHERE job_id = $6
RETURNING job_id, created_at, started_at, finished_at, next_retry_at, max_retries, retry_attempt, status, error, arguments
`

type UpdateJobParams struct {
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	FinishedAt pgtype.Timestamp `json:"finished_at"`
	Status     GoqueueJobStatus `json:"status"`
	Error      pgtype.Text      `json:"error"`
	Arguments  []byte           `json:"arguments"`
	JobID      int32            `json:"job_id"`
}

func (q *Queries) UpdateJob(ctx context.Context, arg UpdateJobParams) (GoqueueJob, error) {
	row := q.db.QueryRow(ctx, updateJob,
		arg.CreatedAt,
		arg.FinishedAt,
		arg.Status,
		arg.Error,
		arg.Arguments,
		arg.JobID,
	)
	var i GoqueueJob
	err := row.Scan(
		&i.JobID,
		&i.CreatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.NextRetryAt,
		&i.MaxRetries,
		&i.RetryAttempt,
		&i.Status,
		&i.Error,
		&i.Arguments,
	)
	return i, err
}

const updateJobFailed = `-- name: UpdateJobFailed :one
UPDATE goqueue_jobs
SET
    status = 'failed',
    next_retry_at = $1,
    error = $2
WHERE job_id = $3
RETURNING job_id, created_at, started_at, finished_at, next_retry_at, max_retries, retry_attempt, status, error, arguments
`

type UpdateJobFailedParams struct {
	NextRetryAt pgtype.Timestamp `json:"next_retry_at"`
	Error       pgtype.Text      `json:"error"`
	JobID       int32            `json:"job_id"`
}

func (q *Queries) UpdateJobFailed(ctx context.Context, arg UpdateJobFailedParams) (GoqueueJob, error) {
	row := q.db.QueryRow(ctx, updateJobFailed, arg.NextRetryAt, arg.Error, arg.JobID)
	var i GoqueueJob
	err := row.Scan(
		&i.JobID,
		&i.CreatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.NextRetryAt,
		&i.MaxRetries,
		&i.RetryAttempt,
		&i.Status,
		&i.Error,
		&i.Arguments,
	)
	return i, err
}

const updateJobFinished = `-- name: UpdateJobFinished :one
UPDATE goqueue_jobs
SET
    status = 'finished',
    finished_at = NOW()
WHERE job_id = $1
RETURNING job_id, created_at, started_at, finished_at, next_retry_at, max_retries, retry_attempt, status, error, arguments
`

func (q *Queries) UpdateJobFinished(ctx context.Context, jobID int32) (GoqueueJob, error) {
	row := q.db.QueryRow(ctx, updateJobFinished, jobID)
	var i GoqueueJob
	err := row.Scan(
		&i.JobID,
		&i.CreatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.NextRetryAt,
		&i.MaxRetries,
		&i.RetryAttempt,
		&i.Status,
		&i.Error,
		&i.Arguments,
	)
	return i, err
}

const updateJobStatus = `-- name: UpdateJobStatus :one
UPDATE goqueue_jobs
SET status = $1
WHERE job_id = $2
RETURNING job_id, created_at, started_at, finished_at, next_retry_at, max_retries, retry_attempt, status, error, arguments
`

type UpdateJobStatusParams struct {
	Status GoqueueJobStatus `json:"status"`
	JobID  int32            `json:"job_id"`
}

func (q *Queries) UpdateJobStatus(ctx context.Context, arg UpdateJobStatusParams) (GoqueueJob, error) {
	row := q.db.QueryRow(ctx, updateJobStatus, arg.Status, arg.JobID)
	var i GoqueueJob
	err := row.Scan(
		&i.JobID,
		&i.CreatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.NextRetryAt,
		&i.MaxRetries,
		&i.RetryAttempt,
		&i.Status,
		&i.Error,
		&i.Arguments,
	)
	return i, err
}
