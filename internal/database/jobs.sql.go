// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: jobs.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getJob = `-- name: GetJob :one
SELECT job_id, created_at, finished_at, status, error, arguments
FROM goqueue_jobs
WHERE status = 'available'
LIMIT 1
`

func (q *Queries) GetJob(ctx context.Context) (GoqueueJob, error) {
	row := q.db.QueryRow(ctx, getJob)
	var i GoqueueJob
	err := row.Scan(
		&i.JobID,
		&i.CreatedAt,
		&i.FinishedAt,
		&i.Status,
		&i.Error,
		&i.Arguments,
	)
	return i, err
}

const insertJob = `-- name: InsertJob :one
INSERT INTO goqueue_jobs (created_at, finished_at, status, error, arguments)
VALUES ($1, $2, $3, $4, $5)
RETURNING job_id, created_at, finished_at, status, error, arguments
`

type InsertJobParams struct {
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	FinishedAt pgtype.Timestamp `json:"finished_at"`
	Status     string           `json:"status"`
	Error      pgtype.Text      `json:"error"`
	Arguments  []byte           `json:"arguments"`
}

func (q *Queries) InsertJob(ctx context.Context, arg InsertJobParams) (GoqueueJob, error) {
	row := q.db.QueryRow(ctx, insertJob,
		arg.CreatedAt,
		arg.FinishedAt,
		arg.Status,
		arg.Error,
		arg.Arguments,
	)
	var i GoqueueJob
	err := row.Scan(
		&i.JobID,
		&i.CreatedAt,
		&i.FinishedAt,
		&i.Status,
		&i.Error,
		&i.Arguments,
	)
	return i, err
}

const updateJob = `-- name: UpdateJob :one
UPDATE goqueue_jobs
SET created_at = $1,
    finished_at = $2,
    status = $3,
    error = $4,
    arguments = $5
WHERE job_id = $6
RETURNING job_id, created_at, finished_at, status, error, arguments
`

type UpdateJobParams struct {
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	FinishedAt pgtype.Timestamp `json:"finished_at"`
	Status     string           `json:"status"`
	Error      pgtype.Text      `json:"error"`
	Arguments  []byte           `json:"arguments"`
	JobID      int32            `json:"job_id"`
}

func (q *Queries) UpdateJob(ctx context.Context, arg UpdateJobParams) (GoqueueJob, error) {
	row := q.db.QueryRow(ctx, updateJob,
		arg.CreatedAt,
		arg.FinishedAt,
		arg.Status,
		arg.Error,
		arg.Arguments,
		arg.JobID,
	)
	var i GoqueueJob
	err := row.Scan(
		&i.JobID,
		&i.CreatedAt,
		&i.FinishedAt,
		&i.Status,
		&i.Error,
		&i.Arguments,
	)
	return i, err
}
